<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="_.js"></script>

</head>
<body>
<script>
    let users = [
        { id: 1, name: 'ID', age:36} ,
        { id: 2, name: 'BJ', age:32} ,
        { id: 3, name: 'JM', age:27} ,
        { id: 4, name: 'PJ', age:25} ,
        { id: 5, name: 'HA', age:26} ,
        { id: 6, name: 'JE', age:31} ,
        { id: 7, name: 'JI', age:33} ,
        { id: 7, name: 'MP', age:23}
    ];

    //1. 명령형 코드
    //1. 30세 이상인 USERS 를 거른다.
    let temp_users = [];
    for( let i=0; i<users.length; i++) {
        if (users[i].age>30) {
            temp_users.push(users[i]);
        }
    }
    // console.log(temp_users);

    //2. 30세 이상인 users의 names를 수집한다.
    let names =[];
    for(let i=0; i<temp_users.length; i++) {
        names.push(temp_users[i].name);
    }
    // console.log(names);

    //3. 30세 미만인 users를 거른다.
    let temp_users2 =  [];
    for (let i=0; i<users.length; i++) {
        if(users[i].age<30) {
            temp_users2.push(users[i]);
        }
    }
    // console.log(temp_users2);

    //4. 30세 미만인 users의 age를 수집한다.
    let ages =[];
    for(let i=0; i<temp_users2.length; i++) {
        ages.push(temp_users2[i].age);
    }
    // console.log(ages);

    // 1과 3은 조건문이 다르다. ->
    // 2. _filter 로 리팩토링
    // function _filter(users, predi) {
    //     let new_list = [];
    //     for( let i=0; i<users.length; i++) {
    //       if(predi(users[i])) {
    //           new_list.push(users[i]);
    //       }
    //
    //         // if (users[i].age>30) { // 이 부분이 중복-> 함수로 받자(predi)
    //         //     temp_users.push(users[i]);
    //         // }
    //     }
    //     // console.log()는 외부에 영향을 미침
    //     return new_list;
    // }

    // 데이터가 어떻게 생겼는지 볼 수 없다 -> 재사용성 극대화
    function _map(list, mapper) {
        let new_list =[]; //새로운 값
        for(let i=0; i<list.length; i++) {
            new_list.push(mapper(list[i]));
        }
        return new_list;
    }

    // users를 쓸 수 도 있고
    let over_30 = _filter(users, function(user) {return user.age >= 30;});
    console.log(over_30);

    // 30넘는 users만 쓸 수도 있고
    let name2 =_map(over_30, function(user){
      return user.name;
    });
    // console.log(name2);

    // 30 미만 users도 쓸 수도 이꼬
    let under_30 = _filter(users, function(user) {return user.age <30;});
    // console.log(under_30);

    let ages2 = _map(under_30, function(user) {return user.age;});
    // console.log(ages2);


    // 대입문을 없앨 수 있다.
    // 아래처럼 아예 인자를 안에 넣으면됨
    // console.log("new...",
    _map(
        _filter(users, function(user) { return user.age>=30; }),
        function(user) { return user.name; }
    );


    console.log("1",
        _filter(users, function(user) { return user.age >= 30; })
    );
    console.log("2",
        _filter(users, function(user) { return user.age < 30; })
    );


    // _filter: 응용형 함수: 함수가 함수를 받아서 원하는 시점에 해당하는 함수가 알고있는 인자를 적용하는것
    //        :고차함수 :함수 안에서 함수를 받는 것

    console.log(
        _filter([1,2,3,4], function(num) {return num%2;}));



    //2021-03-30
    // 3. 커링- 함수와 인자를 다루는 기법, 모든 인자가 다 채워지면 함수 실행
    // 1. _curry, _curryr
    function _curry(fn) { // 인자로 본체함수 받고, _curry 실행하면 바로 _curry리턴 함수 실행,
        return function(a,b) { //인자 개수 상관없음
            return (arguments.length===2) ? fn(a,b) : function(b) { return fn(a,b); } // 인자가 두개가 아니면 함수 호출
        }
    } // 함수가 함수를 대신 실행하거나 조합하는것을 함수형 프로그래밍이라고 한다.


    function _curryr(fn) {
        return function(a,b) { // 먼저들어온 애가 =============================> 오른쪽에 적용용
           return (arguments.length===2) ? fn(a,b) : function(b) { return fn(b,a); }
        }
    }

    let subs = _curryr(function(a, b) {
       return a - b;
    });

    console.log( subs(12,5)) ;
    let sub100 = subs(100); // 먼저 들어온 애가 뒤로
    console.log(sub100(80)); // -20


    let add = _curry(function(a,b) {
        return a+b;
    })
    let add10 = add(10); //미리한번 적용해서 변수에 함수를 넣음  //하나만 인자를 적용하면 함수를 리턴함
    console.log(add10(5));

    console.log(add(10)(5));
    console.log(add(15,2));

    let sub = _curry(function(a,b) {
       return a - b;
    });
    console.log( sub(10,5));
    let sub10 = sub(10);
    console.log('sub10(5)..> ',sub10(5));

    // 원래는 왼쪽부터 인자 적용하지만 curryr은 오른쪽 인자부터 적용한다.

    //2. _get 만들어 좀 더 안전하게 get 해오기
    let _get = _curryr(function(obj, key) {
        return obj == null ? undefined :obj[key];
    });

    let user1 = users[0];
    //console.log(user1.name);
    console.log(_get(user1, 'name'));
    console.log(_get('name')(user1)); //curryr 적용했음

    let get_name = _get('name');
    console.log(get_name(user1));

    //console.log(users[10].name); // 에러가 남.
    //console.log(_get(users[10], 'name')); // null비교할 땐 === 하지말자
    console.log(
    _map(
        _filter(users, function(user) { return user.age>=30; }), // user가 30이 넘는 user들 중에서
        _get('name') // 오른쪽과 같음 function(user) { return user.name; } // name만 뽑아라
    )
    );

    console.clear();


    //4. _reduce 만들기

    //array-like에도 slice를 쓸 수 있게 하는 방법 call을 사용한다.
    //let slice = Array.prototype.slice;
    //slice.call(a,2);
    let slice = Array.prototype.slice;
    function _rest(list, num) {
        return slice.call(list, num || 1) // 넘겨준 값이 없으면 list를 1로..
    }

    console.log(_reduce([1,2,3], add, 10));

    //세번째 인자가 생략 가능하다
    console.log(_reduce([1,2,3,4,5,6], add)); // 세번째 인자가 없으면 list.length-1만큼만 iter 돌도록 해라

    console.clear();

    function _filter(list, predi) {
        let new_list = [];
        _each(list, function(val) {
            if(predi(val)) new_list.push(val);
        });
        return new_list;
    }
    function _each(list, iter) {
        for( let i=0; i<list.length; i++) {
            iter(list[i]);
        }
        return list;
    }

    function _reduce(list, iter, memo) { //list를 가지고 iter함수를 해서 축약된 새로운 자료를 만들기 위해서 사용한다. filter는 그대로
        if(arguments.length === 2) {
            memo = list[0];
            list = _rest(list);
            // list = list.slice(1); 이건 배열만 사용 가능
        }
        _each(list, function(val) {
            memo = iter(memo, val)
        })
        return memo;
    }

    //5. 파이프 함수 (함수리턴 함수) (
    // reduce의 특화 함수라고 생각하기
    function _pipe() {
        let fns = arguments;
        return function(arg) {  //let pipe10 = _pipe(10)
            return _reduce(fns, function(arg, fn) { //클로저로 만들어놨던 fns를 담는다.
                return fn(arg);
            }, arg) // 인자를 시작값
        }
    }

    //함수를 인자로 받아서 차례대로 실행하는 함수
    let f1 = _pipe(
        function(a){return a+1;},
        function(a){return a*2;},
        function(a){return a*3;});

    console.log(f1(1));

    //6. go : 즉시실행되는 파이프함수
    function _go(args) {
        let fns = _rest(arguments);
        return _pipe.apply(null, fns)(args);
    }
    _go(1,
        function(a){return a+1;},
        function(a){return a*2;},
        function(a){return a*3;},
        console.log);


    // users에 _go 적용
    console.log(
        _map(
            _filter(users, function(user) { return user.age>=30; }), // user가 30이 넘는 user들 중에서
            _get('name') // 오른쪽과 같음 function(user) { return user.name; } // name만 뽑아라
        )
    );
    _go(users,
        function(users) {
            return _filter(users,function(user) {
                return user.age>=30;
            });
        },
        function(users) {
            return _map(users, _get('name'))
        }
    );
    console.log(
        _map([1,2,3], function(val){return val *2})
    )

    // // curryr이 적용된 map과 filter
    let _map2 = _curryr(_map)
    let _filter2 = _curryr(_filter);
    console.log(
        _map2( function(val){ return val*2 })([1,2,3])
    )


</script>

</body>
</html>